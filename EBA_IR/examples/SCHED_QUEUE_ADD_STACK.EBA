// sched queue add
// adds something to the queue. If there is no room, nothing is added
// another continuation is called based on whether something was added
// args buffer contains
// 0: this code (always)
// 1: queue intself
// 2: the STACK of bufs to add to the queue
// 3: buf to call on success
// 4: buf to call on failure


MEMOP READ_FROMBUF V13, V0, &08 // grab the queue buf

MEMOP READ_FROMBUF V1, V13, &00 // data
MEMOP READ_FROMBUF V2, V13, &08 // size
MEMOP READ_FROMBUF V3, V13, &16 // head
MEMOP READ_FROMBUF V4, V13, &24 // tail
MEMOP READ_FROMBUF V5, V13, &32 // full


MEMOP READ_FROMBUF V11, V0, &16 // grab the stack of bufs


BUFREQ ALLOC V9, &8 // occupied space buffer (into available space buf)

MATHOP MUL_U64 V9, V2, V5 // occupied space = full*size
MATHOP ADD_U64 V9, V9, V4 // occupied space += tail
MATHOP SUB_U64 V9, V9, V3 // occupied space -= head
CMP GEQ        V4, V3, SKIP_WRAPAROUND_ADD
MATHOP ADD_U64 V6, V6, V2 // if tail_buf < head_buf, add size buf
SKIP_WRAPAROUND_ADD:

MATHOP SUB_U64 V9, V2, V9 // now hold available space

CMP GT V11, V9, ADD_FAIL // if I have to add more than is available, go to fail

// check for mods, make sure it's mod 8
MATHOP MOD_U64 V9, V11, &0
CMP NEQ V9, &0, ADD_FAIL
BUFREQ RELEASE V9

LOOP_BEGIN:
CMP EQ V11, &0, DONE

MEMOP TRANSFER_WITH_OFFSET V1, V4, V11, V11, &8
// transfer 8 bytes (an arg buf)
// from the arg buf stack at its listed index
// to the circular queue at its tail
MATHOP SUB_U64 V11, V11, &8
INVOKE ADD_U64 V4, V4, &8 // tail = tail+8
INVOKE MOD_U64 V4, V4, V2 // tail = tail % size

CMP EQ, &0, &0, LOOP_BEGIN

DONE:
BUFREQ RELEASE V11
// prepare to call the next buf
MEMOP READ_FROMBUF V6, V0, &24
RELEASE V0
MEMOP MOVE V0, V6
INVOKE LOCAL_BUF V0



ADD_FAIL:
BUFREQ RELEASE V9
MEMOP READ_FROMBUF V6, V0, &32
RELEASE V0
MEMOP MOVE V0, V6
INVOKE LOCAL_BUF V0
